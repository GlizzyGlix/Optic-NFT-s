/* eslint-disable require-atomic-updates */
/* eslint-disable no-await-in-loop */

/*
 * This is the main script to run the Flipance bot. It coordinates all the
different modules, polling offers, collection floors and user's tokens and also
listens to blockchain events.
 */

import path from "path";
import dotenv from "dotenv";
import { readFileSync } from "fs";
import { Client, Intents } from "discord.js";
import {
  nftEventEmitter as createNFTEventEmitter,
  createNFTClient,
} from "../src/blockchain/index.js";
import logError from "../src/log-error.js";
import {
  handleInteraction,
  registerCommands,
  buildEmbed,
} from "../src/discord/index.js";
import sleep from "../src/sleep.js";
import { createDbClient } from "../src/database/index.js";
import { getDefaultProvider } from "ethers";

dotenv.config({ path: path.resolve(".env") });

const marketplaces = JSON.parse(readFileSync("data/marketplaces.json"));
const nftEvents = JSON.parse(readFileSync("data/nft-events.json"));

const allMarketplaceIds = marketplaces.map(({ id }) => id);
const allEventIds = nftEvents.map(({ id }) => id);

const {
  ETHERSCAN_API_KEY,
  INFURA_PROJECT_ID,
  POCKET_PROJECT_ID,
  POCKET_SECRET_KEY,
  ALCHEMY_API_KEY,
  DISCORD_BOT_TOKEN,
  DISCORD_BOT_TOKEN_TEST,
  MAX_OFFER_FLOOR_DIFFERENCE,
} = process.env;

const EVENT_LISTENER_REFRESH_PERIOD = 5 * 60 * 1000;
const POLL_USER_TOKENS_INTERVAL = 5 * 60 * 1000;

const ethProvider = getDefaultProvider("homestead", {
  etherscan: ETHERSCAN_API_KEY,
  infura: INFURA_PROJECT_ID,
  pocket: {
    applicationId: POCKET_PROJECT_ID,
    applicationSecretKey: POCKET_SECRET_KEY,
  },
  alchemy: ALCHEMY_API_KEY,
});

const discordClient = new Client({ intents: [Intents.FLAGS.GUILDS] });
const [, , testArg] = process.argv;
discordClient.login(
  testArg === "test" ? DISCORD_BOT_TOKEN_TEST : DISCORD_BOT_TOKEN
);

if (testArg === "test") {
  console.log(`Starting the client in TEST mode`);
}

/**
 * Determine whether a user/server should be notified of an NFT event
 * based on their preferences
 * @param {Object} params
 * @param {String} params.marketplace - The marketplace id. You can find
 * the whole list at data/marketplaces.json.
 * @param {String} params.eventType - The event type.  You can find
 * the whole list at data/nft-events.json.
 * @param {Number} params.collectionFloor - The latest floor price for
 * the NFT's collection.
 * @param {Number} params.price - The price associated to the event. If
 * it is a sale, the sale price. If it's an offer, the offer price.
 * @param {Object} settings
 * @param {Array[String]} allowedMarketplaces - List of allowed marketplace ids.
 * @param {Array[String]} allowedEvents - List of allowed NFT event ids.
 * @param {Number} maxOfferFloorDifference - Max. deviation from the collection
 * floor an offer can have to be relevant to the alert.
 * @return {Boolean}
 */
const isAllowedByPreferences = (
  { marketplace, eventType, collectionFloor, price },
  {
    allowedMarketplaces = allMarketplaceIds,
    allowedEvents = allEventIds,
    maxOfferFloorDifference = Number(MAX_OFFER_FLOOR_DIFFERENCE),
  } = {}
) => {
  if (
    !allowedMarketplaces.includes(marketplace) ||
    !allowedEvents.includes(eventType)
  ) {
    return false;
  }

  if (eventType === "offer" && collectionFloor != null) {
    if (price >= collectionFloor) {
      return true;
    }

    const floorDifference = (collectionFloor - price) / collectionFloor;
    return 100 * floorDifference < Number(maxOfferFloorDifference);
  }

  return true;
};

/*
 * Handles a collection offer event generated by the nft event emitter.
 * If the offer is higher than the current highest offer, the bot will
 * attempt to notify the discord servers that watch the collection.
 */
const handleOffer = async ({ args, dbClient, collectionMap }) => {
  const { collection, marketplace, price, endsAt: offerEndsAt } = args;
  const {
    highestOffer = 0,
    offerEndsAt: currentEndsAt,
    watchers,
    collectionFloor,
  } = collectionMap[collection];
  if (price > highestOffer || currentEndsAt < new Date().getTime()) {
    await dbClient.setCollectionOffer({
      address: collection,
      price,
      endsAt: offerEndsAt,
      marketplace,
    });
    watchers.forEach(async (watcher) => {
      const { discordId, channelId, tokenIds } = watcher;
      if (isAllowedByPreferences({ ...args, collectionFloor }, watcher)) {
        try {
          const isUserMessage = channelId == null;
          const target = await (isUserMessage
            ? discordClient.users.fetch(discordId)
            : discordClient.channels.fetch(channelId));
          const embed = await buildEmbed({
            ...args,
            target: isUserMessage ? "user" : "server",
            tokenIds,
          });
          target.send(embed).catch((error) => {
            logError(
              `Error sending bid notification to ${channelId}/${discordId}; Error: ${error.toString()}`
            );
          });
        } catch (error) {
          logError(
            `Error handling bid with args ${JSON.stringify({
              ...args,
            })}: ${error.toString()}`
          );
        }
      }
    });
  }
};

/*
 * Handles a collection listing event generated by the nft event emitter.
 */
const handleListing = async ({ args, dbClient, collectionMap }) => {
  const { collection, marketplace, price, endTime: endsAt } = args;
  const { watchers } = collectionMap[collection];
  await dbClient.setCollectionOffer({
    address: collection,
    price,
    endsAt,
    marketplace,
  });
  watchers.forEach(async (watcher) => {
    const { discordId, channelId, tokenIds } = watcher;
    if (isAllowedByPreferences(args, watcher)) {
      try {
        const isUserMessage = channelId == null;
        const target = await (isUserMessage
          ? discordClient.users.fetch(discordId)
          : discordClient.channels.fetch(channelId));
        const embed = await buildEmbed({
          ...args,
          target: isUserMessage ? "user" : "server",
          tokenIds,
        });
        target.send(embed).catch((error) => {
          logError(
            `Error sending listing notification to ${channelId}/${discordId}; Error: ${error.toString()}`
          );
        });
      } catch (error) {
        logError(
          `Error handling listing with args ${JSON.stringify({
            ...args,
          })}: ${error.toString()}`
        );
      }
    }
  });
};

/*
 * Handle NFT events coming from the blockchain. If there is an alert
 * set up for the buyer, seller or collection, notify the user/server
 * that created that alert.
 */
const handleNFTEvent = async ({ args, dbClient, collectionMap }) => {
  const {
    seller: sellerAddress = "",
    buyer: buyerAddress = "",
    collection: collectionAddress = "",
    eventType,
  } = args;

  if (eventType === "offer") {
    return handleOffer({ args, dbClient, collectionMap });
  }

  if (eventType === "listing") {
    return handleListing({ args, dbClient, collectionMap });
  }

  const { objects: sellerAlerts } = await dbClient.getAlertsByAddress({
    address: sellerAddress.toLowerCase(),
  });
  if (sellerAlerts.length > 0) {
    sellerAlerts
      .filter((alert) => isAllowedByPreferences(args, alert))
      .forEach(async ({ discordId }) => {
        try {
          const discordUser = await discordClient.users.fetch(discordId);
          const embed = await buildEmbed({
            ...args,
            isSeller: true,
          });
          discordUser.send(embed).catch((error) => {
            logError(
              `Error sending message to seller ${discordId}; Error: ${error.toString()}`
            );
          });
        } catch (error) {
          logError(
            `Could not notify user ${discordId} of sale; Error: ${error.toString()}`
          );
        }
      });
  }

  const { objects: buyerAlerts } = await dbClient.getAlertsByAddress({
    address: buyerAddress.toLowerCase(),
  });

  if (buyerAlerts.length > 0) {
    buyerAlerts
      .filter((buyer) => isAllowedByPreferences(args, buyer))
      .forEach(async ({ discordId }) => {
        try {
          const discordUser = await discordClient.users.fetch(discordId);
          const embed = await buildEmbed({
            ...args,
            isBuyer: true,
          });
          discordUser.send(embed).catch((error) => {
            logError(
              `Error sending message to buyer ${discordId}; Error: ${error.toString()}`
            );
          });
        } catch (error) {
          logError(
            `Could not notify user ${discordId} of purchase; Error: ${error.toString()}`
          );
        }
      });
  }

  const { objects: collectionAlerts } = await dbClient.getAlertsByAddress({
    address: collectionAddress.toLowerCase(),
  });
  if (collectionAlerts.length > 0) {
    collectionAlerts
      .filter((alert) => isAllowedByPreferences(args, alert))
      .forEach(async ({ channelId }) => {
        if (channelId == null) {
          return;
        }

        try {
          const embed = await buildEmbed({
            ...args,
          });
          const channel = await discordClient.channels.fetch(channelId);
          channel.send(embed);
        } catch (error) {
          logError(
            `Error sending collection alert to channel ${channelId}: ${error.toString()}`
          );
        }
      });
  }

  return null;
};

/**
 * This function takes as parameter already-configured clients and is in
 * charge of monitoring blockchain events on the target marketplaces and
 * notifying users/servers of these events.
 * @param {Object} params
 * @param {Object} params.dbClient - The initialized database client.
 * @param {Object} params.nftClient - The initialized client to poll NFT
 * information.
 */
const monitorBlockchainEvents = async ({ dbClient, nftClient }) => {
  /*
   * Updates the tokens associated to an alert to always monitor the
   * offers for collections that users own.
   */
  const updateAlertTokens = async (alerts) => {
    let index = 0;
    while (index < alerts.length) {
      const { id, address, type, syncedAt } = alerts[index];
      if (
        type === "wallet" &&
        (syncedAt == null ||
          new Date() - new Date(syncedAt) > POLL_USER_TOKENS_INTERVAL)
      ) {
        const tokens = await nftClient.getAddressNFTs(address);
        alerts[index].tokens = tokens;
        alerts[index].syncedAt = new Date();
        await dbClient.setAlertTokens({ id, tokens });
      }

      index += 1;
    }

    return alerts;
  };

  /*
   * Creates a map where each collection address has associated a list of
   * watchers (users and servers), token ids, current offer price and expiry.
   * The purpose of this map is to pull information only for the collections
   * which are relevant to users.
   */
  const createCollectionMap = async () => {
    const { objects: alerts } = await dbClient.getAllAlerts();
    const updatedAlerts = await updateAlertTokens(alerts);
    const { objects: offers } = await dbClient.getAllCollectionOffers();
    const collectionMap = updatedAlerts.reduce(
      (collectionMap, { id, tokens, ...alert }) => {
        const userCollections = tokens.reduce((collections, token) => {
          const [collection, tokenId] = token.split("/");
          if (tokenId.length > 0) {
            const tokenIds = collections[collection] || [];
            collections[collection] = tokenIds.concat(tokenId);
          }

          return collections;
        }, {});
        Object.entries(userCollections).forEach(([collection, tokenIds]) => {
          const { watchers: currentWatchers = [] } =
            collectionMap[collection] || {};
          collectionMap[collection] = {
            watchers: currentWatchers.concat([{ ...alert, id, tokenIds }]),
          };
        });
        // Set collection offers
        offers.forEach(({ collection, price, endsAt }) => {
          const current = collectionMap[collection];
          if (current == null) {
            return;
          }

          current.highestOffer = price;
          current.endsAt = endsAt;
          collectionMap[collection] = current;
        });
        return collectionMap;
      },
      {}
    );
    const floors = await Promise.all(
      Object.keys(collectionMap).map((collection) =>
        dbClient.getCollectionFloor(collection).then(({ object }) => object)
      )
    );
    // Set collection floors
    floors
      .filter((floor) => floor != null)
      .forEach(({ collection, price }) => {
        const current = collectionMap[collection];
        if (current == null) {
          return;
        }

        current.collectionFloor = price;
        collectionMap[collection] = current;
      });

    return collectionMap;
  };

  console.time("collection-map");
  const collectionMap = await createCollectionMap();
  console.timeEnd("collection-map");
  const nftEventEmitter = createNFTEventEmitter(
    ethProvider,
    Object.keys(collectionMap)
  );
  nftEventEmitter.on("event", (args) => {
    try {
      handleNFTEvent({ args, dbClient, collectionMap });
    } catch (error) {
      logError(
        `Error handling sale with args ${JSON.stringify(
          args
        )}: ${error.toString()}`
      );
    }
  });
  await sleep(EVENT_LISTENER_REFRESH_PERIOD);
  nftEventEmitter.destroy();
  return monitorBlockchainEvents({ dbClient, nftClient });
};

discordClient.once("ready", async () => {
  console.log(`Logged in as ${discordClient.user.tag}!`);
  const dbClient = await createDbClient();
  const nftClient = await createNFTClient();

  monitorBlockchainEvents({ dbClient, nftClient });
  discordClient.on("interactionCreate", (interaction) => {
    handleInteraction({ discordClient, nftClient, dbClient }, interaction);
  });

  discordClient.on("error", (error) => {
    logError(`Bot encountered error:`, error);
  });

  discordClient.on("shardError", (error) => {
    logError("A websocket connection encountered an error:", error);
  });
});

discordClient.on("guildCreate", (guild) => {
  console.log(`Guild create event: ${guild.id}`);
  registerCommands(guild.id);
});

process.on("unhandledRejection", (error) => {
  logError("Unhandled promise rejection:", error);
});
